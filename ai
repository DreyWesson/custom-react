I need you to implement createContext api like react in my custom react implementation for global state management
import { App } from "./App.jsx"; import { createRealDOM, diff } from "./helper/domHelpers"; class MyReact { constructor() { this.state = []; this.stateIdx = 0; this.effects = []; this.effectIdx = 0; this.isRendering = false; this.oldVDOM = null; this.container = null; this.isUpdateScheduled = false; } useState = (initialValue) => { const idx = this.stateIdx; if (!this.isRendering) { throw new Error("useState can only be called during rendering"); } if (this.state[idx] === undefined) { this.state[idx] = initialValue; } const setState = (newValue) => { const newState = typeof newValue === "function" ? newValue(this.state[idx]) : newValue; this.state[idx] = newState; this.processUpdate(); }; this.stateIdx++; return [this.state[idx], setState]; }; useEffect = (callback, dependencies = []) => { const idx = this.effectIdx; if (!this.isRendering) { throw new Error("useEffect can only be called during rendering"); } const previousEffect = this.effects[idx]; const depsChanged = previousEffect ? dependencies.some((dep, i) => !Object.is(dep, previousEffect.deps[i])) : true; if (depsChanged) { if (previousEffect?.cleanup) { previousEffect.cleanup(); } const cleanup = callback(); this.effects[idx] = { deps: dependencies, cleanup: typeof cleanup === "function" ? cleanup : undefined, }; } this.effectIdx++; }; runEffects = () => { this.effects.forEach((effect) => { if (effect && effect.depsChanged) { if (effect.cleanup) effect.cleanup(); effect.cleanup = effect.callback(); } }); }; processUpdate = () => { if (!this.isUpdateScheduled) { this.isUpdateScheduled = true; requestAnimationFrame(() => { this.isUpdateScheduled = false; this.render(); }); } }; render = (app = App, container) => { this.isRendering = true; this.stateIdx = 0; this.effectIdx = 0; container = container || this.container || document.getElementById("root"); this.renderToDOM(app(), container); this.isRendering = false; this.runEffects(); }; renderToDOM = (newVDOM, root) => { this.container = root; if (!this.oldVDOM) root.appendChild(createRealDOM(newVDOM)); else diff(root, this.oldVDOM, newVDOM); this.oldVDOM = newVDOM; }; createElement = (type, props = {}, ...children) => { props = props || {}; const { key = null, ...restProps } = props; const normalizedChildren = children.flat().map((child, index) => { if (typeof child === "object" && child !== null && !child.key) { child.key = index; } return child; }); return typeof type === "function" ? type({ ...restProps, children: normalizedChildren }) : { type, props: { ...restProps, children: normalizedChildren }, key, }; }; } 
import { updateProps, hasNodeChanged, createKeyedMap } from "./index"; export const handleHTML = (element) => { const { key, children, ...props } = element.props; const domElement = document.createElement(element.type); updateProps(domElement, {}, props); appendChildren(domElement, children); return domElement; }; export const createRealDOM = (element) => { if (typeof element === "string" || typeof element === "number") { return document.createTextNode(String(element)); } if (!element || !element.type) { return document.createTextNode(""); } if (typeof element.type === "function") { const renderedElement = element.type(element.props); return createRealDOM(renderedElement); } return handleHTML(element); }; export const appendChildren = (domElement, children) => { children .filter((child) => { return ( child != null && child !== false && child !== "" && typeof child !== "boolean" ); }) .map((child) => createRealDOM(child)) .forEach((child) => domElement.appendChild(child)); }; export const diff = (parent, oldNode, newNode, index = 0) => { const existingNode = parent.childNodes[index]; if (typeof newNode === "string" || typeof newNode === "number") { if (existingNode.nodeType === Node.TEXT_NODE) { if (existingNode.textContent !== String(newNode)) { existingNode.textContent = String(newNode); } } else { const newTextNode = document.createTextNode(String(newNode)); parent.replaceChild(newTextNode, existingNode); } return; } if (!newNode) { if (existingNode) parent.removeChild(existingNode); return; } if (!oldNode) { parent.appendChild(createRealDOM(newNode)); return; } if (hasNodeChanged(oldNode, newNode)) { const newDomNode = createRealDOM(newNode); parent.replaceChild(newDomNode, existingNode); return; } if (newNode.type) { updateProps(existingNode, oldNode.props, newNode.props); diffChildren(existingNode, oldNode.props.children, newNode.props.children); } }; export const diffChildren = (parent, oldChildren = [], newChildren = []) => { const oldChildrenKeyed = createKeyedMap(oldChildren); const newChildrenKeyed = createKeyedMap(newChildren); const handledIndices = updateNewChildren( parent, newChildren, oldChildren, oldChildrenKeyed ); removeOldChildren(parent, oldChildren, newChildrenKeyed, handledIndices); }; export const updateNewChildren = ( parent, newChildren, oldChildren, oldChildrenKeyed ) => { const handledIndices = new Set(); newChildren.forEach((newChild, i) => { const oldChild = oldChildrenKeyed[newChild?.key] || oldChildren[i]; diff(parent, oldChild, newChild, i); handledIndices.add(i); }); return handledIndices; }; export const removeOldChildren = ( parent, oldChildren, newChildrenKeyed, handledIndices ) => { oldChildren.forEach((oldChild, i) => { if (!handledIndices.has(i) && !newChildrenKeyed[oldChild?.key]) { diff(parent, oldChild, null, i); } }); }; 
export const createKeyedMap = (children) => { return children.reduce((acc, child, index) => { if (child && child.key != null) acc[child.key] = child; else acc[index] = child; return acc; }, {}); }; export const hasNodeChanged = (node1, node2) => { return ( typeof node1 !== typeof node2 || ((typeof node1 === "string" || typeof node1 === "number") && node1 !== node2) || node1.type !== node2.type || node1.key !== node2.key ); }; export const removeProp = (domElement, name, value) => { if (name.startsWith("on")) { const eventType = name.toLowerCase().substring(2); domElement.removeEventListener(eventType, value); } else if (name === "style") { domElement.style = ""; } else if (name in domElement) { domElement[name] = ""; } else { domElement.removeAttribute(name); } }; export const updateProps = (domElement, oldProps, newProps) => { removeOldProps(domElement, oldProps, newProps); addNewProps(domElement, oldProps, newProps); }; export const addNewProps = (domElement, oldProps, newProps) => { for (let name in newProps) { if (name === "children") continue; if (name === "style") { const oldStyle = oldProps[name] || {}; const newStyle = newProps[name] || {}; for (let styleName in newStyle) { if (oldStyle[styleName] !== newStyle[styleName]) { domElement.style[styleName] = newStyle[styleName]; } } } else if (name === "value" && domElement.tagName === "INPUT") { if (domElement.value !== newProps[name]) { domElement.value = newProps[name] || ""; } domElement.setAttribute("value", newProps[name] || ""); } else if (isPropChanged(oldProps[name], newProps[name])) { setProp(domElement, name, newProps[name]); } } }; export const removeOldProps = (domElement, oldProps, newProps) => { for (let name in oldProps) { if (name === "children") continue; if (name === "style") { const oldStyle = oldProps[name] || {}; const newStyle = newProps[name] || {}; for (let styleName in oldStyle) { if (!(styleName in newStyle)) { domElement.style[styleName] = ""; } } } else if (!(name in newProps)) { removeProp(domElement, name, oldProps[name]); } } }; export const setProp = (domElement, name, value) => { if (name.startsWith("on")) { const eventType = name.toLowerCase().substring(2); domElement.removeEventListener(eventType, domElement[name]); domElement.addEventListener(eventType, value); domElement[name] = value; } else if (name === "style") { domElement.style.cssText = value; } else if (name in domElement) { domElement[name] = value; } else { domElement.setAttribute(name, value); } }; export const isPropChanged = (oldValue, newValue) => { return oldValue !== newValue; };

import { Button } from "./Button.jsx"; import { createElement, useEffect, useState } from "../myReact.js"; export const Posts = () => { const [posts, setPosts] = useState([]); const [error, setError] = useState(null); const [userId, setUserId] = useState(1); useEffect(() => { const controller = new AbortController(); const signal = controller.signal; const fetchData = async () => { try { const response = await fetch( https: { signal } ); if (!response.ok) throw new Error("Network response was not ok"); const data = await response.json(); setPosts(data.slice(0, 5)); } catch (error) { if (error.name !== "AbortError") { setError("Failed to fetch items"); } } }; fetchData(); return () => { controller.abort(); }; }, [userId]); return ( <section style={{ margin: "0" }}> <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", padding: "5px", }} > <h2>Latest Posts</h2> <span> useID: <span style={{ color: "red", fontWeight: "bold" }}>{userId}</span> </span> </div> <ul style={{ display: "flex", flexDirection: "column", margin: "0", padding: "0", }} > {posts.map((item) => ( <li key={item.id} style={{ listStyle: "none", marginBottom: "10px" }}> <strong>{item.title}</strong> <p>{item.body}</p> </li> ))} <Button onClick={() => setUserId((id) => id + 1)}> Load Next User's Posts </Button> </ul> </section> ); }; 
import { Button } from "./Button.jsx"; import { Input } from "./Input.jsx"; import { Posts } from "./Posts.jsx"; import { createElement, useState, useEffect } from "../myReact.js"; import { useLogic } from "./useLogic.jsx"; function Greeting(props) { return ( <div> <h4>Hello {props.name}</h4> <p>This is a functional component within a virtual DOM structure</p> </div> ); } const vDOM = { type: Greeting, props: { name: "John" }, }; function Sectioning() { return ( <div> <br /> <hr /> <br /> </div> ); } export const Main = () => { const { color, count, toggleColor, handleComplexEvent, toggleMessage, showMessage, handleSubmit, inputValue, handleInputChange, isActive, toggleIsActive, user, updateAge, setCount, } = useLogic(); return ( <main id="content"> <Posts /> <Sectioning /> {vDOM} <Sectioning /> <section className="intro"> <hr /> <h3> This is an example of a normal HTML page rendered using MyReact. </h3> <div style={{ marginTop: "10px" }}> <h1>Count: {count}</h1> <Button onClick={() => setCount(count + 1)} style={{ marginRight: "10px" }} > Increment </Button> <Button onClick={toggleColor}>Toggle Color</Button> <Button onClick={handleComplexEvent} style={{ marginLeft: "10px" }}> Increment by 5 and toggle color </Button> </div> <Sectioning /> <div style={{ marginTop: "20px" }}> <Button onClick={toggleMessage} style={{ marginRight: "10px" }}> Toggle Message </Button> {showMessage && <p>This is a conditional message!</p>} </div> <Sectioning /> <form onSubmit={handleSubmit} style={{ marginTop: "20px" }}> <Input value={inputValue} onInput={handleInputChange} placeholder="Enter text..." /> <button type="submit">Submit</button> </form> <Sectioning /> <div className={isActive ? "active" : "inactive"} style={{ marginTop: "20px" }} > <Button onClick={toggleIsActive}> {isActive ? "Active" : "Inactive"} </Button> </div> <Sectioning /> <div style={{ marginTop: "20px" }}> <p>Name: {user.name}</p> <p>Age: {user.age}</p> <Button onClick={updateAge}>Increment Age</Button> </div> </section> </main> ); }; 
import { createElement } from "../myReact"; export const Input = ({ value, onInput, placeholder }) => { return ( <input type="text" value={value} onInput={onInput} placeholder={placeholder} /> ); };
import { createElement, useState } from "../myReact.js"; import { useLogic } from "./useLogic.jsx"; export const Header = (prop) => { const [items] = useState(["Home", "About", "Contact"]); const {color} = useLogic(); return ( <header id="main-header" style={{ backgroundColor: color, padding: "10px", textAlign: "center" }} > <h1>Welcome to My React Page</h1> <nav style={{ margin: "0" }}> <h3>Testing list</h3> <ul style={{ display: "flex", justifyContent: "space-between", width: "150px", margin: "0 auto", padding: "0", }} > {items && items.map((item, idx) => ( <li key={idx} style={{ listStyle: "none" }}> <a style={{ color: "#fff", fontWeight: "bold", textDecoration: "none", }} href={#${item.toLowerCase()}} > {item} </a> </li> ))} </ul> </nav> </header> ); };
import { createElement } from "../myReact"; export const Footer = () => { return ( <footer id="main-footer" style={{ marginTop: "20px", textAlign: "center" }}> <p>© 2024 My Page</p> </footer> ); };
import { createElement } from "../myReact"; export const Button = ({ onClick, children, style }) => { return ( <button onClick={onClick} style={style}> {children} </button> ); };